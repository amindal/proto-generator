//go:build gen2

package main

import (
	"bytes"
	"fmt"
	"go/types"
	"io"
	"os"
	"regexp"
	"strings"
	"text/template"
	"unicode"

	"github.com/emicklei/proto"
	"gitter.top/common/protofmt"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"golang.org/x/tools/go/packages"
)

const (
	// FileHeaderTemplate protobuf file header
	FileHeaderTemplate = `syntax = "proto3";

package ProjectName;

`
	// TiledTemplate tiled style message, default style
	TiledTemplate = `{{range $name, $message := .SubMessage}}message {{$name}} {
{{range $idx, $field := $message.Fields}}{{if $field.Repeated}}repeated {{end}} {{$field.Type}} {{$field.Name}} = {{add $idx 1}};
{{end}}
}
{{end}}
message AutoGenerated {
{{range $idx, $field := .Fields}}{{if $field.Repeated}}repeated {{end}} {{$field.Type}} {{$field.Name}} = {{add $idx 1}};
{{end}}
}`
	// EmbedTemplate embed style message
	EmbedTemplate = `message AutoGenerated {
	{{range $name, $message := .SubMessage}}message {{$name}} {
{{range $idx, $field := $message.Fields}}{{if $field.Optional}}optional {{end}}{{if $field.Repeated}}repeated {{end}} {{$field.Type}} {{$field.Name}} = {{add $idx 1}};
{{end}}
}
{{end}}
{{range $idx, $field := .Fields}}{{if $field.Optional}}optional {{end}}{{if $field.Repeated}}repeated {{end}} {{$field.Type}} {{$field.Name}} = {{add $idx 1}};
{{end}}
}`
)

var structJsonPattern = regexp.MustCompile(`json:"([^"]+)"`)

type Field struct {
	Repeated bool   `json:"repeated,omitempty"`
	Optional bool   `json:"optional,omitempty"`
	Type     string `json:"type,omitempty"`
	Name     string `json:"name,omitempty"`
}

type Message struct {
	SubMessage map[string]*Message `json:"sub_message,omitempty"`
	Fields     []*Field            `json:"fields,omitempty"`
}

type Parser struct {
	StructName           string
	FileHeaderDefinition bool
	TiledDefinition      bool
	MergeMessage         bool
	_data                map[string]interface{}
	_rawMessage          *Message
	_tiledMessage        *Message
}

func Add(x, y int) int {
	return x + y
}

func validFieldName(field string) bool {
	if len(field) == 0 {
		return false
	}
	firstChar := rune(field[0])
	if firstChar == '_' {
		return false
	}
	if !unicode.IsLetter(firstChar) {
		return false
	}
	for _, char := range field[1:] {
		if !unicode.IsLetter(char) && !unicode.IsNumber(char) && char != '_' {
			return false
		}
	}
	return true
}

func (p *Parser) validName(raw *Message) error {
	for _, field := range raw.Fields {
		if !validFieldName(field.Name) {
			return fmt.Errorf("invalid field name '%s'", field.Name)
		}
	}

	for mName, message := range raw.SubMessage {
		if !validFieldName(mName) {
			return fmt.Errorf("invalid message name '%s'", mName)
		}

		for _, field := range message.Fields {
			if !validFieldName(field.Name) {
				return fmt.Errorf("invalid field name '%s.%s'", mName, field.Name)
			}
		}
	}

	return nil
}

func (p *Parser) merge(a, b *Message) ([]*Field, error) {
	var fieldMap = make(map[string]*Field)
	for _, field := range a.Fields {
		fieldMap[field.Name] = field
	}
	for _, field := range b.Fields {
		old, exist := fieldMap[field.Name]
		if !exist {
			fieldMap[field.Name] = field
			continue
		}
		if field.Repeated != old.Repeated {
			return nil, fmt.Errorf("conflect field %s on repeated attribute", old.Name)
		}
		if field.Type != old.Type {
			return nil, fmt.Errorf("conflect field %s on type attribute", old.Type)
		}
	}
	var newFields []*Field
	for _, field := range fieldMap {
		newFields = append(newFields, field)
	}
	return newFields, nil
}

func (p *Parser) tiled(messages map[string]*Message) error {
	if len(messages) == 0 {
		return nil
	}
	for name, message := range messages {
		if err := p.tiled(message.SubMessage); err != nil {
			return err
		}
		old, exist := p._tiledMessage.SubMessage[name]
		if !exist {
			p._tiledMessage.SubMessage[name] = message
			continue
		}
		mergeFields, err := p.merge(message, old)
		if err != nil {
			return err
		}
		p._tiledMessage.SubMessage[name].Fields = mergeFields
	}
	return nil
}

func (p *Parser) ProtobufTemplateRender(tpl string) (io.ReadWriter, error) {
	if p.FileHeaderDefinition {
		tpl = FileHeaderTemplate + tpl
	}
	p._tiledMessage = &Message{SubMessage: make(map[string]*Message)}
	tmpl, err := template.New("file_template").Funcs(template.FuncMap{"add": Add}).Parse(tpl)
	if err != nil {
		return nil, err
	}
	if err := p.tiled(p._rawMessage.SubMessage); err != nil {
		return nil, err
	}
	p._tiledMessage.Fields = p._rawMessage.Fields
	// validate message
	if err := p.validName(p._tiledMessage); err != nil {
		return nil, err
	}
	var buffer = new(bytes.Buffer)
	err = tmpl.Execute(buffer, p._tiledMessage)
	if err != nil {
		return nil, err
	}
	return buffer, nil
}

func (p *Parser) format(buf io.ReadWriter) string {
	pp := proto.NewParser(buf)
	parse, err := pp.Parse()
	if err != nil {
		return err.Error()
	}
	protofmt.NewFormatter(buf, "    ").Format(parse)
	var buffer bytes.Buffer
	_, _ = buffer.ReadFrom(buf)
	return buffer.String()
}

func (p *Parser) Output() string {
	var tpl = EmbedTemplate
	if p.TiledDefinition {
		tpl = TiledTemplate
	}
	tpl = strings.ReplaceAll(tpl, "AutoGenerated", p.StructName)
	writer, err := p.ProtobufTemplateRender(tpl)
	if err != nil {
		failErr(err)
	}
	return p.format(writer)
}

func main() {
	if len(os.Args) != 4 {
		failErr(fmt.Errorf("expected exactly one argument: <source type>"))
	}
	goPackage := os.Args[1]
	projectName := os.Args[2]
	outputPath := os.Args[3]

	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports | packages.NeedDeps}
	pkgs, err := packages.Load(cfg, goPackage)
	if err != nil {
		failErr(err)
	}
	pkg := pkgs[0]
	messages := ""
	for _, t := range pkg.Types.Scope().Names() {
		obj := pkg.Types.Scope().Lookup(t)
		if obj == nil {
			failErr(fmt.Errorf("error in lookup %v", t))
		}
		structObj, ok := obj.Type().Underlying().(*types.Struct)
		if ok && structObj.NumFields() > 0 {

			if strings.HasSuffix(obj.Name(), "Response") ||
				strings.HasSuffix(obj.Name(), "Params") ||
				strings.HasSuffix(obj.Name(), "Request") {
				p := &Parser{
					MergeMessage: true,
				}
				var recognizeMessage func(s *types.Struct) *Message
				recognizeMessage = func(s *types.Struct) *Message {
					var msg = &Message{SubMessage: make(map[string]*Message)}
					for i := 0; i < s.NumFields(); i++ {
						field := s.Field(i)
						if field.Name()[0] != strings.ToUpper(field.Name())[0] {
							continue
						}
						tag := s.Tag(i)
						matched := structJsonPattern.FindStringSubmatch(tag)
						if len(matched) == 0 {
							failErr(fmt.Errorf("invalid json tag : %v.%v", obj.Name(), field.Name()))
						}
						var recognizeType func(t types.Type, name string) Field
						recognizeType = func(t types.Type, name string) Field {
							f := Field{}
							switch v := t.(type) {
							case *types.Basic:
								f.Type = GoType2ProtoType(v.Kind())
							case *types.Array:
								f.Repeated = true
								subType := v.Elem()
								f.Type = recognizeType(subType, name+"_items").Type
							case *types.Slice:
								f.Repeated = true
								subType := v.Elem()
								f.Type = recognizeType(subType, name+"_items").Type
							case *types.Struct:
								f.Type = UnderscoreToUpperCamelCase(name)
								m := recognizeMessage(v)
								msg.SubMessage[f.Type] = m
							case *types.Pointer:
								f.Optional = true
								f.Type = recognizeType(v.Elem(), name+"_item").Type
							default:
								f.Type = "google.protobuf.Any"
							}
							return f
						}
						fd := recognizeType(field.Type(), matched[1])
						fd.Name = matched[1]
						msg.Fields = append(msg.Fields, &fd)
					}
					return msg
				}
				ms := recognizeMessage(structObj)
				p.StructName = obj.Name()
				p._rawMessage = ms
				messages += p.Output() + "\n"
			}

		}
	}

	messagesFile, err := os.OpenFile(outputPath, os.O_CREATE|os.O_WRONLY, 0777)
	if err != nil {
		failErr(err)
	}
	defer messagesFile.Close()
	messagesFile.WriteString(strings.ReplaceAll(FileHeaderTemplate, "ProjectName", projectName) + messages)
}

func GoType2ProtoType(to types.BasicKind) string {
	switch to {
	case types.Int8, types.Int16, types.Int32:
		return "sint32"
	case types.Int, types.Int64:
		return "sint64"
	case types.Uint8, types.Uint16, types.Uint32:
		return "fixed32"
	case types.Uint, types.Uint64:
		return "fixed64"
	case types.Bool:
		return "bool"
	case types.String:
		return "string"
	case types.Float32:
		return "float"
	case types.Float64:
		return "double"
	default:
		failErr(fmt.Errorf("invalid type %v", to))
		return ""
	}
}

func UnderscoreToUpperCamelCase(s string) string {
	s = strings.Replace(s, "_", " ", -1)
	s = cases.Title(language.English).String(s)
	return strings.Replace(s, " ", "", -1)
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
